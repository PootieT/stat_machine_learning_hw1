import numpy as np
import math
import sys
import scipy.linalg as linalg
import matplotlib as mpl
import matplotlib.pyplot as plt

class ProbabilityModel:

	# Returns a single sample (independent of values returned on previous calls).
	# The returned value is an element of the model's sample space.
	def sample(self):
		pass


# The sample space of this probability model is the set of real numbers, and
# the probability measure is defined by the density function 
# p(x) = 1/(sigma * (2*pi)^(1/2)) * exp(-(x-mu)^2/2*sigma^2)
class UnivariateNormal(ProbabilityModel):
	
	# Initializes a univariate normal probability model object
	# parameterized by mu and (a positive) sigma
	def __init__(self,mu,sigma):
		self.mu = mu
		self.sigma = sigma

	# generate a random variable within the provided signma and mu
        #box mueller transformation
	def next(self):
		u1 = np.random.uniform()
		u2 = np.random.uniform()
		z0 = np.sqrt(-2.0*np.log(u1)) * np.cos(2*np.pi * u2)
		return z0 *self.sigma + self.mu

	def cumulative_density_function(self, x):
		return 0.5 + 0.5 * math.erf((x-self.mu)/(self.sigma*math.sqrt(2)))

	def density_function(self, x):
		return 1/(self.sigma * (2*math.pi)**(1/2)) * math.exp(-(x-self.mu)**2/2*self.sigma**2)

# The sample space of this probability model is the set of D dimensional real
# column vectors (modeled as numpy.array of size D x 1), and the probability 
# measure is defined by the density function 
# p(x) = 1/(det(Sigma)^(1/2) * (2*pi)^(D/2)) * exp( -(1/2) * (x-mu)^T * Sigma^-1 * (x-mu) )
class MultiVariateNormal(ProbabilityModel):
	
	# Initializes a multivariate normal probability model object 
	# parameterized by Mu (numpy.array of size D x 1) expectation vector 
	# and symmetric positive definite covariance Sigma (numpy.array of size D x D)
	def __init__(self,Mu,Sigma):
		self.Mu = Mu
		self.Sigma = Sigma

	# generate a vector of normally distributed variables
	def next(self):
		n = 1
		uni_model = UnivariateNormal(0,1)
		p = len(self.Mu)
		L = np.linalg.cholesky(self.Sigma)
		X = np.array([uni_model.next() for i in range(n*p)]).reshape((n,p))
		return (np.dot(L,X.T).T + self.Mu)[0]

# The sample space of this probability model is the finite discrete set {0..k-1}, and 
# the probability measure is defined by the atomic probabilities 
# P(i) = ap[i]
class Categorical(ProbabilityModel):
	
	# Initializes a categorical (a.k.a. multinom, multinoulli, finite discrete) 
	# probability model object with distribution parameterized by the atomic probabilities vector
	# ap (numpy.array of size k).
	def __init__(self,ap):
		self.ap = ap

	# with atopic probability vector, return the probablilty of the catagory chosen
	def next(self):
		x = np.random.uniform()
		idx = 0
		thresh = self.ap[0]
		while x >= thresh:
			idx += 1
			thresh += self.ap[idx]
		return self.ap[idx]


# The sample space of this probability model is the union of the sample spaces of 
# the underlying probability models, and the probability measure is defined by 
# the atomic probability vector and the densities of the supplied probability models
# p(x) = sum ad[i] p_i(x)
class MixtureModel(ProbabilityModel):
	
	# Initializes a mixture-model object parameterized by the
	# atomic probabilities vector ap (numpy.array of size k) and by the tuple of 
	# probability models pm
	def __init__(self,ap,pm):
		self.ap = ap
		self.Mu_list = pm[0]
		self.Sigma_list = pm[1]

	def next(self):
		x = np.random.uniform()
		idx = 0
		thresh = self.ap[0]
		while x >= thresh:             # pick which distribution model we will use
			idx += 1
			thresh += self.ap[idx]      
		multi_norm_model = MultiVariateNormal(self.Mu_list[idx], self.Sigma_list[idx]) # sample with given mu and sigma using multi variate model
		return multi_norm_model.next()


# model = UnivariateNormal(100,10)
# print model.next()

# model = MultiVariateNormal(np.array([1,1]),np.array([[1,0],[0,1]]))
# print(model.next())

# model = Categorical(np.array([0.1,0.3,0.6]))
# print model.next()

def hw1_plot1():
	# plot 1: histogram of 1000 samples generated by catagorical distribution with 
	#         proabability distribution [0.2, 0.4, 0.3, 0.1]
	ap = [0.2, 0.4, 0.3, 0.1]
	cat_model = Categorical(ap)
	accumulation = [0, 0, 0, 0]
	for _ in range(1000):
		x = cat_model.next()
		accumulation[0] += (x == 0.2)
		accumulation[1] += (x == 0.4)
		accumulation[2] += (x == 0.3)
		accumulation[3] += (x == 0.1)
	print accumulation
	objects = ('Category 1 (0.2)', 'Category 2 (0.4)','Category 3 (0.3)','Category 4 (0.1)',)
	y_pos = np.arange(len(objects))
	plt.bar(y_pos,accumulation,align='center', alpha=0.5)
	plt.xticks(y_pos, objects)
	plt.ylabel('Count')
	plt.title('Category Occurance')
	for a,b in zip(y_pos, accumulation):
		plt.text(a-0.1, b+5, str(b))
	plt.show()

def hw1_plot2():
	# plot 2: plot univariate normal distribution with mean of 10 and standard 
	#         deviation of 1
	mu = 10
	sigma = 1
	bins = 20
	sample_size = 1000
	uni_model = UnivariateNormal(mu, sigma)
	samples = [uni_model.next() for i in range(sample_size)]
	plt.hist(samples, bins, alpha = 0.5)
	plt.title("Gaussian Histogram (n =" + str(sample_size) + ')')
	plt.xlabel("Value")
	plt.ylabel("Frequency")
	plt.show()
	fig = plt.gcf()

def hw1_plot3():
	# plot 3: Produce a scatter plot of the samples for a 2-D Gaussian with mean
	#         at [1,1] and a covariance matrix [[1,0.5],[0.5,1]]
	Mu = np.array([1,1])
	Sigma = np.array([[1,0.5],[0.5,1]])
	multi_model = MultiVariateNormal(Mu, Sigma)
	sample_size = 1000
	X = []
	Y = []
	for _ in range(sample_size):
		x, y = multi_model.next()
		X.append(x)
		Y.append(y)
	plt.scatter(X, Y)
	plt.title("2-D Gaussian Distribution")
	plt.xlabel("x value")
	plt.ylabel("y value")
	plt.show()

def hw1_test4():
	# Test your mixture sampling code by writing a function that implements an equal-
	# weighted mixture of four Gaussians in 2 dimensions, centered at (+-1, +-1) and having
	# covariance I. Estimate the probability that a sample from this distribution lies within
	# the unit circle centered at (0.1, 0.2)
	ap = [0.25, 0.25, 0.25, 0.25]
	Mu_list = [np.array([-1,-1]),np.array([1,-1]),np.array([-1,1]),np.array([1,1])]
	Sigma_list = [np.identity(2),np.identity(2),np.identity(2),np.identity(2)]
	mix_model = MixtureModel(ap, [Mu_list, Sigma_list])
	sample_size = 100000
	true = 0
	for _ in range(sample_size):
		x, y =  mix_model.next()
		if (x-0.1)**2 + (y-0.2)**2 <= 1:
			true += 1
		# print x, y
	return (true+0.0)/sample_size

# hw1_plot1()
# hw1_plot2()
hw1_plot3()
#print hw1_test4()

